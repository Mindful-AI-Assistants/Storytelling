# -*- coding: utf-8 -*-
"""1a_finalfile_project2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12AGHEHjzovNIGC1DbH1ABiV1tbP0d628
"""

import pandas as pd  # manipulação e análise de dados.
import numpy as np #  arrays, matrizes e funções matemáticas
import matplotlib.pyplot as plt #  módulo matplotlib para gráficos
import matplotlib.cm as cm  # módulo matplotlib para manipular cores
import seaborn as sns # vizualizacao de dados e criacao de graficos
import plotly.express as px # graficos interativos (pouco codigo)
import matplotlib.font_manager as fm  # Listar fontes disponíveis
import matplotlib.gridspec as gridspec # Mais flexibilidade para organizar seus gráficos no dashboard.

# ... (código para ler o dataset - substitua pelo path de seu arquivo viia upload) ...
# A linha countryData.drop("Unnamed: 0", axis = 1) remove uma coluna desnecessária chamada "Unnamed: 0", que provavelmente foi criada durante a exportação do CSV.

countryData = pd.read_csv("/content/countryData.csv").drop("Unnamed: 0", axis = 1)
countryData

# Informações sobre os dados, como o número de linhas e colunas, os tipos de dados de cada coluna e algumas estatísticas descritivas.

countryData.shape  # Mostra o número de linhas e colunas
countryData.info() # Mostra os tipos de dados de cada coluna
countryData.describe() # Mostra estatísticas descritivas (média, desvio padrão, etc.)

# 1-Definição de regiões: Uma lista chamada regions é criada com os nomes das regiões.
# 2-Seleção de dados: O código seleciona as colunas "country" e a coluna especificada pelo argumento coluna do DataFrame countryData, removendo linhas com valores ausentes (dropna()).
# 3-Agrupamento por país: Os dados são agrupados por país usando o método groupby("country"), e a soma dos valores da coluna especificada é calculada para cada país
# 4-Cálculo por região
# 5-Retorno de dados: A função retorna duas listas: regions com os nomes das regiões e countryPerData com os valores calculados para cada região.

def separacaoRegiao(countryData, coluna):
    regions = ["Norte America", "Asia", "Africa", "Sul da Asia"]
    countryPerData = countryData[["country", coluna]].dropna()
    countryPerData = countryPerData.groupby("country").sum()
    countryPerData = [countryPerData[coluna].iloc[1] + countryPerData[coluna].iloc[9],
                    countryPerData[coluna].iloc[2] + countryPerData[coluna].iloc[5],
                    countryPerData[coluna].iloc[3] + countryPerData[coluna].iloc[6] + countryPerData[coluna].iloc[7],
                    countryPerData[coluna].iloc[0] + countryPerData[coluna].iloc[4] + countryPerData[coluna].iloc[8]]
    return regions, countryPerData

# cria uma lista chamada country que contém todos os países únicos presentes na coluna "country" do DataFrame countryData.
# O código itera sobre cada valor da coluna "country" e verifica se o país já está presente na lista country. Se não estiver, o país é adicionado à lista.
# método unique() do pandas para obter uma lista de valores únicos diretamente
# Outra formna mais simples de usar o unique é : set(def)

country = countryData["country"].unique()

import matplotlib.font_manager as fm

# Listar fontes disponíveis
font_list = [f.name for f in fm.fontManager.ttflist]
print(font_list)

# Escolha uma fonte da lista e use-a no código
plt.rcParams['font.family'] = 'STIXGeneral'  # Substitua pelo nome da fonte escolhida

# Tema Escuro
plt.style.use('dark_background')

### 1-Gráfico de GDP per capta
dimensao, dash1 = plt.subplots(2, 1, figsize = (25, 10))
plt.subplots_adjust(hspace = 0.7)
for pos, paises in enumerate(country):
    dash1[0].plot(countryData.loc[countryData["country"] == paises, "year"], countryData.loc[countryData["country"] == paises, "GDP Per Capita (USD)"], label = paises, color = plt.cm.tab20(pos))
dash1[0].set_xlabel("Year", fontsize = 15)
dash1[0].set_ylabel("GDP Per Capita (USD)", fontsize = 15)
dash1[0].set_title("GDP per capta desde 2012", fontsize = 18)
dash1[0].legend(loc=(0.97, 0), prop = {"size": 15})
dash1[0].spines["top"].set_visible(False)
dash1[0].spines["right"].set_visible(False)
dash1[0].spines["left"].set_visible(False)
dash1[0].spines["bottom"].set_visible(False)
dash1[0].grid(axis = "y", alpha = 0.5)

# Cores vibrantes
cmap = plt.cm.get_cmap('plasma')  # ou 'viridis', 'inferno' etc.
for pos, paises in enumerate(country):
    dash1[0].plot(countryData.loc[countryData["country"] == paises, "year"],
                  countryData.loc[countryData["country"] == paises, "GDP Per Capita (USD)"],
                  label=paises, color=cmap(pos / len(country)))  # Substitua ... pelos argumentos corretos

# Fontes claras e legíveis
plt.rcParams['font.family'] = 'STIXGeneral'  # Use uma fonte disponível
plt.rcParams['text.color'] = 'white'
plt.rcParams['axes.labelcolor'] = 'white'
plt.rcParams['xtick.color'] = 'white'
plt.rcParams['ytick.color'] = 'white'
dash1[0].set_xlabel("Year", fontsize = 18)
dash1[0].set_ylabel("GDP Per Capita (USD)", fontsize = 18)
dash1[0].set_title("GDP per capta desde 2012", fontsize = 22)

# Linhas mais espessas e marcadores
for line in dash1[0].lines:
    line.set_linewidth(2.5)  # Ajuste a espessura
    line.set_marker('o')  # Adiciona marcadores



### 2-Gráfico de acesso à eletricidade

cmap = plt.cm.get_cmap('plasma')  # ou 'viridis', 'inferno' etc.

for pos, paises in enumerate(country):
    dash1[1].plot(countryData.loc[countryData["country"] == paises, "year"],
                  countryData.loc[countryData["country"] == paises, "Access to electricity"],
                  label=paises, color=cmap(pos / len(country)));

dash1[1].legend(loc=(0.97, 0), prop={"size": 15})
dash1[1].spines["top"].set_visible(False)
dash1[1].spines["bottom"].set_visible(False)
dash1[1].spines["right"].set_visible(False)
dash1[1].spines["left"].set_visible(False)
dash1[1].grid(axis="y", alpha=0.5)
dash1[1].set_ylim(32, 101)
dash1[1].set_xticks(range(2011, 2022, 1))  # Ajuste o intervalo de anos se necessário
dash1[1].set_title("Acesso à energia per capita desde 2012", fontsize=18)
dash1[1].set_xlabel("Year", fontsize=18)
dash1[1].set_ylabel("Acesso à energia (%)", fontsize=18)  # Adicione a unidade de medida


### 3-GRÁFICOS DE PIZZA

regions, countryPerData = separacaoRegiao(countryData, "Energy use per capita")

# Paleta de cores vibrantes adaptada ao tema escuro
colors = ['#F92672', '#66D9EF', '#A6E22E', '#FD971F']  # Exemplos de cores vibrantes

dimensao, dash = plt.subplots(1, 4, figsize=(25, 2))
plt.subplots_adjust(hspace=2)

# Ajustes para o tema escuro
plt.style.use('dark_background')  # Fundo escuro
plt.rcParams['text.color'] = 'white'  # Texto em branco

dash[0].pie(countryPerData, explode=(0.1, 0.1, 0, 0), labels=regions, colors=colors,
           autopct='%1.1f%%', shadow=True, startangle=140, textprops={'fontsize': 10})
dash[0].set_title("Energia per capita por Continente", fontsize=12)  # Ajuste o tamanho da fonte


## Gráfico de pizza 2

regions, countryPerData = separacaoRegiao(countryData, "co2 emissions")

# Reutilizando a paleta de cores vibrantes
colors = ['#F92672', '#66D9EF', '#A6E22E', '#FD971F']

# Ajustes para o tema escuro já foram aplicados no código anterior

dash[1].pie(countryPerData, explode=(0.1, 0, 0, 0), labels=regions, colors=colors,
           autopct='%1.1f%%', shadow=True, startangle=140, textprops={'fontsize': 10})
dash[1].set_title("Emissão de CO2 por Continente", fontsize=12)  # Ajuste o tamanho da fonte


## Gráfico de pizza 3
regions, countryPerData = separacaoRegiao(countryData, "Inflation")

# #Reutilizando a paleta de cores vibrantes
colors = ['#F92672', '#66D9EF', '#A6E22E', '#FD971F']

# Ajustes para o tema escuro já foram aplicados no código anterior
dash[2].pie(countryPerData, explode=(0, 0, 0, 0.1), labels=regions, colors=colors,
           autopct='%1.1f%%', shadow=True, startangle=140, textprops={'fontsize': 10})
dash[2].set_title("Inflação por Continente", fontsize=12)  # Ajuste o tamanho da fonte


 ## Gráfico de pizza 4 (PIZZA CHAT)
regions, countryPerData = separacaoRegiao(countryData, "Access to electricity")

# Reutilizando a paleta de cores vibrantes
colors = ['#F92672', '#66D9EF', '#A6E22E', '#FD971F']

# Ajustes para o tema escuro já foram aplicados no código anterior

dash[3].pie(countryPerData, explode=(0.1, 0, 0, 0), labels=regions, colors=colors,
           autopct='%1.1f%%', shadow=True, startangle=140, textprops={'fontsize': 10})
dash[3].set_title("Acesso à eletricidade por Continente", fontsize=12)  # Ajuste o tamanho da fonte


# Verificar valores ausentes em 'Inflation'
print(countryData['Inflation'].isnull().sum())

# Remover linhas com valores ausentes (opcional)
countryData.dropna(subset=['Inflation'], inplace=True)


### 4-Gráfico de inflação por Continente (BUBLLE CHART)
plt.figure(figsize=(25, 2.5))

# Cores vibrantes
cmap = plt.cm.get_cmap('plasma') # Escolhe o mapa de cores 'plasma' para cores vibrantes

for i, pais in enumerate(country):  # Itera sobre cada país e seu índice na lista 'country'
    plt.scatter(countryData.loc[countryData['country'] == pais, "year"],  # Define os valores do eixo x (ano) para cada país
                countryData.loc[countryData['country'] == pais, 'Inflation'],  # Define os valores do eixo y (inflação) para cada país
                alpha=0.7,  # Define a opacidade das bolhas (0 = transparente, 1 = opaco)
                color=cmap(i / len(country)),  # Define a cor de cada bolha com base no índice e no número de países
                label=pais,  # Define o rótulo de cada bolha com o nome do país
                s=countryData.loc[countryData['country'] == pais, 'Inflation'] * 10)
                # Define o tamanho da bolha proporcional ao valor da inflação


# Ajustes para o tema escuro
plt.style.use('dark_background')  # Define o estilo do gráfico como 'dark_background' para fundo escuro
plt.rcParams['text.color'] = 'white'  # Define a cor do texto como branco para melhor visibilidade


# Remove as bordas do gráfico
plt.gca().spines["right"].set_visible(False)
plt.gca().spines["bottom"].set_visible(False)
plt.gca().spines["top"].set_visible(False)
plt.gca().spines["left"].set_visible(False)

# Define os rótulos do eixo x (anos) e sua cor
plt.xticks(range(2012, 2022, 1), color='white')

# Define a cor dos rótulos do eixo y
plt.yticks(color='white')

# Define o rótulo do eixo x, seu tamanho e cor
plt.xlabel("Year", fontsize=18, color='white')

# Define o rótulo do eixo y, seu tamanho e cor
plt.ylabel("Inflação", fontsize=18, color='white')

# Define o título do gráfico, seu tamanho e cor
plt.title("Inflação por País", fontsize=22, color='white')

# Define a posição da legenda e o tamanho da fonte
plt.legend(loc=(1, 0), prop={'size': 10})

# Ajustar espaçamento entre os gráficos
plt.tight_layout()

# Salvar a imagem
plt.savefig("project_2.png", dpi=300)  # # Nome do arquivo a sua escolha e DPI

plt.show()